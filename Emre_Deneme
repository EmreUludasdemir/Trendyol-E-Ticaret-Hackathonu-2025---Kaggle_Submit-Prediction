{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "d15c7799",
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "execution": {
     "iopub.execute_input": "2025-08-18T12:13:06.632950Z",
     "iopub.status.busy": "2025-08-18T12:13:06.632628Z",
     "iopub.status.idle": "2025-08-18T12:27:34.074635Z",
     "shell.execute_reply": "2025-08-18T12:27:34.073604Z"
    },
    "papermill": {
     "duration": 867.449905,
     "end_time": "2025-08-18T12:27:34.077533",
     "exception": false,
     "start_time": "2025-08-18T12:13:06.627628",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[link] train_sessions.parquet -> /kaggle/input/trendyol/data/train_sessions.parquet\n",
      "[link] test_sessions.parquet -> /kaggle/input/trendyol/data/test_sessions.parquet\n",
      "[link] content/metadata.parquet -> /kaggle/input/trendyol/data/content/metadata.parquet\n",
      "[link] content/price_rate_review_data.parquet -> /kaggle/input/trendyol/data/content/price_rate_review_data.parquet\n",
      "[link] content/search_log.parquet -> /kaggle/input/trendyol/data/content/search_log.parquet\n",
      "[link] content/sitewide_log.parquet -> /kaggle/input/trendyol/data/content/sitewide_log.parquet\n",
      "[link] user/metadata.parquet -> /kaggle/input/trendyol/data/user/metadata.parquet\n",
      "[link] user/sitewide_log.parquet -> /kaggle/input/trendyol/data/user/sitewide_log.parquet\n",
      "[link] term/search_log.parquet -> /kaggle/input/trendyol/data/term/search_log.parquet\n",
      "[duckdb] View'lar oluşturuluyor...\n",
      "[duckdb] Özet tablolar oluşturuluyor...\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "76da190758bd421ebdb101fa095c402b",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "FloatProgress(value=0.0, layout=Layout(width='auto'), style=ProgressStyle(bar_color='black'))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "60f009a6e84a4132824287b6dd71cd06",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "FloatProgress(value=0.0, layout=Layout(width='auto'), style=ProgressStyle(bar_color='black'))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "5d22adc8a5f440ec819d43c916c4e45f",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "FloatProgress(value=0.0, layout=Layout(width='auto'), style=ProgressStyle(bar_color='black'))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[duckdb] Eğitim tablosu hazırlanıyor...\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "f6be474f31a04b0398c186e689bd767a",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "FloatProgress(value=0.0, layout=Layout(width='auto'), style=ProgressStyle(bar_color='black'))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[mem] train_df (joined): 1518.39 MB, shape=(2773805, 39)\n",
      "[mem] train_df (+engineered): 1420.51 MB, shape=(2773805, 68)\n",
      "[feat] 63 feature kullanılacak\n",
      "[lgb] clicked fold 0\n",
      "Training until validation scores don't improve for 100 rounds\n",
      "Early stopping, best iteration is:\n",
      "[57]\ttrain's auc: 0.792165\tvalid's auc: 0.645129\n",
      "[lgb] clicked fold 1\n",
      "Training until validation scores don't improve for 100 rounds\n",
      "Early stopping, best iteration is:\n",
      "[57]\ttrain's auc: 0.794396\tvalid's auc: 0.649492\n",
      "[lgb] clicked fold 2\n",
      "Training until validation scores don't improve for 100 rounds\n",
      "Early stopping, best iteration is:\n",
      "[57]\ttrain's auc: 0.795615\tvalid's auc: 0.65087\n",
      "[lgb] ordered fold 0\n",
      "Training until validation scores don't improve for 100 rounds\n",
      "Early stopping, best iteration is:\n",
      "[1]\ttrain's auc: 0.764824\tvalid's auc: 0.704789\n",
      "[lgb] ordered fold 1\n",
      "Training until validation scores don't improve for 100 rounds\n",
      "Early stopping, best iteration is:\n",
      "[1]\ttrain's auc: 0.765706\tvalid's auc: 0.688948\n",
      "[lgb] ordered fold 2\n",
      "Training until validation scores don't improve for 100 rounds\n",
      "Early stopping, best iteration is:\n",
      "[1]\ttrain's auc: 0.766767\tvalid's auc: 0.689166\n",
      "[blend] w=0.55  auc_order=0.709363  auc_click=0.609610  score=0.679437\n",
      "[blend] w=0.60  auc_order=0.709873  auc_click=0.608049  score=0.679326\n",
      "[blend] w=0.65  auc_order=0.710439  auc_click=0.606381  score=0.679221\n",
      "[blend] w=0.70  auc_order=0.711046  auc_click=0.604469  score=0.679073\n",
      "[blend] w=0.75  auc_order=0.711706  auc_click=0.602240  score=0.678866\n",
      "[blend] w=0.80  auc_order=0.712419  auc_click=0.599705  score=0.678605\n",
      "[blend] w=0.85  auc_order=0.713134  auc_click=0.596796  score=0.678233\n",
      "[blend] w=0.90  auc_order=0.713561  auc_click=0.593381  score=0.677507\n",
      "[blend] BEST w=0.550  score=0.679437\n",
      "[info] OOF özet:\n",
      "count    2.773805e+06\n",
      "mean     4.855521e-01\n",
      "std      2.802004e-01\n",
      "min      1.229345e-02\n",
      "25%      2.081382e-01\n",
      "50%      5.684842e-01\n",
      "75%      7.607984e-01\n",
      "max      9.152238e-01\n",
      "dtype: float64\n",
      "[sanity] helpers ready\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "828d7acce2494d4f958f2e9141a195d8",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "FloatProgress(value=0.0, layout=Layout(width='auto'), style=ProgressStyle(bar_color='black'))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[batch] written submission_part_0.csv in 100.5s rows=1999959\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "10dae097117f4506ad42da92c0113bbc",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "FloatProgress(value=0.0, layout=Layout(width='auto'), style=ProgressStyle(bar_color='black'))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[batch] written submission_part_2000000.csv in 55.6s rows=988622\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "b9bc83fb039c4610bc4c0d94cda5c37f",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "FloatProgress(value=0.0, layout=Layout(width='auto'), style=ProgressStyle(bar_color='black'))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[batch] processing leftover rows=116\n",
      "[merge] Parçalar birleştiriliyor…\n",
      "[sanity] uniq_session_in_submission=18589 expected=18589\n",
      "[done] submission yazıldı: submission.csv, satır sayısı = 18589 + başlık\n",
      "[check] İlk 3 satır:\n",
      "              session_id                                         prediction\n",
      "0  test_0001ff614df60933  073576690f347e49 345f9173dbc33204 b1ae3df07f40...\n",
      "1  test_00041895a35c4813  e95b82f982466786 39ad83a925c864b2 5b6dced01b91...\n",
      "2  test_00058d4dc9727758  b22bccb1d5a0ecb0 3eaefd7668f331f1 017a664714e0...\n",
      "\n",
      "Kaggle'a gönderim için:\n",
      "kaggle competitions submit -c trendyol-e-ticaret-hackathonu-2025-kaggle -f submission.csv -m \"LGBM (cats+posw) + engineered feats + tuned blend (NaN-safe clip, fast CV)\"\n"
     ]
    }
   ],
   "source": [
    "# -*- coding: utf-8 -*-\n",
    "# ================================================================\n",
    "# Trendyol E-Ticaret Hackathon 2025 - Tek Hücre Pipeline (FIXED & FASTER)\n",
    "# ================================================================\n",
    "# - DuckDB ile hızlı agregasyon/join\n",
    "# - Zengin feature seti + engineered features (NaN-safe)\n",
    "# - Kategorik sütunlar: LightGBM'e categorical olarak veriliyor\n",
    "# - Sınıf dengesizliği: scale_pos_weight (clicked/ordered ayrı)\n",
    "# - OOF üstünde blend ağırlığı (order/click) taraması\n",
    "# - Testte batch + carry-over + güvenli merge (duplicate session fix)\n",
    "# - \"invalid value encountered in greater/less_equal\" uyarısı: NaN-safe clip\n",
    "# - Eğitim hızlandırma: 3-fold CV, 1500 tur, erken durdurma 100\n",
    "# ================================================================\n",
    "\n",
    "# 0) Bootstrap ve input bağlama\n",
    "import os, glob, shutil, sys, importlib, subprocess, gc, time, math, uuid, json\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import duckdb\n",
    "from datetime import datetime\n",
    "from sklearn.model_selection import GroupKFold\n",
    "from sklearn.preprocessing import LabelEncoder\n",
    "from sklearn.metrics import roc_auc_score\n",
    "import lightgbm as lgb\n",
    "\n",
    "def ensure_packages(pkgs=(\"duckdb\",\"lightgbm\",\"pyarrow\")):\n",
    "    missing=[]\n",
    "    for p in pkgs:\n",
    "        try:\n",
    "            importlib.import_module(p)\n",
    "        except ImportError:\n",
    "            missing.append(p)\n",
    "    if missing:\n",
    "        try:\n",
    "            subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"-q\", *missing])\n",
    "            print(\"[pip] Yüklendi:\", missing)\n",
    "        except Exception as e:\n",
    "            print(\"[pip] Kurulum başarısız veya internet kapalı:\", missing, e)\n",
    "\n",
    "ensure_packages()\n",
    "\n",
    "BASE_IN = \"/kaggle/input\"\n",
    "expected = {\n",
    "    \"train_sessions.parquet\": [\"**/train_sessions.parquet\"],\n",
    "    \"test_sessions.parquet\":  [\"**/test_sessions.parquet\"],\n",
    "    \"content/metadata.parquet\": [\"**/content/**/metadata.parquet\", \"**/metadata.parquet\"],\n",
    "    \"content/price_rate_review_data.parquet\": [\"**/content/**/price_rate_review_data.parquet\", \"**/price_rate_review_data.parquet\"],\n",
    "    \"content/search_log.parquet\": [\"**/content/**/search_log.parquet\", \"**/search_log.parquet\"],\n",
    "    \"content/sitewide_log.parquet\": [\"**/content/**/sitewide_log.parquet\", \"**/sitewide_log.parquet\"],\n",
    "    \"user/metadata.parquet\": [\"**/user/**/metadata.parquet\", \"**/user_metadata.parquet\", \"**/user-meta.parquet\", \"**/user_metadata*.parquet\"],\n",
    "    \"user/sitewide_log.parquet\": [\"**/user/**/sitewide_log.parquet\", \"**/user_sitewide_log.parquet\"],\n",
    "    \"term/search_log.parquet\": [\"**/term/**/search_log.parquet\", \"**/term_search_log.parquet\"],\n",
    "}\n",
    "\n",
    "def ensure_link(src, dst):\n",
    "    os.makedirs(os.path.dirname(dst) or \".\", exist_ok=True)\n",
    "    if os.path.exists(dst):\n",
    "        return\n",
    "    try:\n",
    "        os.symlink(src, dst)\n",
    "        print(f\"[link] {dst} -> {src}\")\n",
    "    except Exception:\n",
    "        shutil.copy2(src, dst)\n",
    "        print(f\"[copy] {dst} <- {src}\")\n",
    "\n",
    "def map_inputs():\n",
    "    root = BASE_IN if os.path.exists(BASE_IN) else \".\"\n",
    "    for dst, patterns in expected.items():\n",
    "        found = None\n",
    "        for pat in patterns:\n",
    "            matches = glob.glob(os.path.join(root, pat), recursive=True)\n",
    "            if matches:\n",
    "                found = matches[0]\n",
    "                break\n",
    "        if not found:\n",
    "            print(f\"[WARN] Bulunamadı: {dst}. Doğru competition/dataset'i Notebook'a eklediğinizden emin olun.\")\n",
    "            continue\n",
    "        ensure_link(found, dst)\n",
    "\n",
    "map_inputs()\n",
    "\n",
    "RANDOM_STATE = 42\n",
    "np.random.seed(RANDOM_STATE)\n",
    "\n",
    "def memory_info(df: pd.DataFrame, name: str = \"DF\"):\n",
    "    mb = df.memory_usage(deep=True).sum() / (1024**2)\n",
    "    print(f\"[mem] {name}: {mb:.2f} MB, shape={df.shape}\")\n",
    "\n",
    "# -------- NaN-safe [0,1] clip (Pandas uyarısı vermez) ----------\n",
    "def safe_clip01(s: pd.Series) -> pd.Series:\n",
    "    arr = s.to_numpy(dtype=\"float32\", copy=False)\n",
    "    arr = np.minimum(np.maximum(arr, 0.0), 1.0)  # NaN'lar korunur\n",
    "    return pd.Series(arr, index=s.index, dtype=\"float32\")\n",
    "\n",
    "# 1) Yardımcılar\n",
    "def label_encode_train_and_map(df: pd.DataFrame, cols):\n",
    "    encoders = {}\n",
    "    for c in cols:\n",
    "        le = LabelEncoder()\n",
    "        df[c] = le.fit_transform(df[c].astype(str))\n",
    "        encoders[c] = le\n",
    "    return df, encoders\n",
    "\n",
    "def label_encode_apply(df: pd.DataFrame, encoders):\n",
    "    # Unseen değerler için classes_ genişlet ve sırala\n",
    "    for c, le in encoders.items():\n",
    "        vals = df[c].astype(str)\n",
    "        unseen = ~vals.isin(le.classes_)\n",
    "        if unseen.any():\n",
    "            new_classes = np.unique(vals[unseen].values)\n",
    "            le.classes_ = np.concatenate([le.classes_, new_classes])\n",
    "            le.classes_.sort()\n",
    "        df[c] = le.transform(vals)\n",
    "    return df\n",
    "\n",
    "def add_time_parts(df: pd.DataFrame, ts_col: str = \"ts_hour\"):\n",
    "    ts = pd.to_datetime(df[ts_col], errors=\"coerce\")\n",
    "    df[\"hour\"]  = ts.dt.hour.astype(\"Int16\")\n",
    "    df[\"dow\"]   = ts.dt.dayofweek.astype(\"Int16\")\n",
    "    df[\"week\"]  = ts.dt.isocalendar().week.astype(\"Int16\")\n",
    "    df[\"month\"] = ts.dt.month.astype(\"Int8\")\n",
    "    # cyclical\n",
    "    hour = df[\"hour\"].fillna(0).astype(float)\n",
    "    dow  = df[\"dow\"].fillna(0).astype(float)\n",
    "    df[\"hour_sin\"] = np.sin(2*np.pi*hour/24).astype(\"float32\")\n",
    "    df[\"hour_cos\"] = np.cos(2*np.pi*hour/24).astype(\"float32\")\n",
    "    df[\"dow_sin\"]  = np.sin(2*np.pi*dow/7).astype(\"float32\")\n",
    "    df[\"dow_cos\"]  = np.cos(2*np.pi*dow/7).astype(\"float32\")\n",
    "    return df\n",
    "\n",
    "# 2) DuckDB bağlantısı ve view'lar\n",
    "con = duckdb.connect(database=\":memory:\")\n",
    "con.execute(\"PRAGMA threads=%d\" % max(1, os.cpu_count()))\n",
    "print(\"[duckdb] View'lar oluşturuluyor...\")\n",
    "\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE VIEW train_sessions AS SELECT * FROM 'train_sessions.parquet';\n",
    "CREATE OR REPLACE VIEW test_sessions  AS SELECT * FROM 'test_sessions.parquet';\n",
    "\n",
    "CREATE OR REPLACE VIEW content_meta AS SELECT \n",
    "  content_id_hashed,\n",
    "  attribute_type_count,\n",
    "  total_attribute_option_count,\n",
    "  merchant_count,\n",
    "  filterable_label_count,\n",
    "  CAST(content_creation_date AS TIMESTAMP) AS content_creation_ts\n",
    "FROM 'content/metadata.parquet';\n",
    "\n",
    "CREATE OR REPLACE VIEW price_reviews AS SELECT \n",
    "  content_id_hashed,\n",
    "  CAST(update_date AS TIMESTAMP) AS update_ts,\n",
    "  original_price,\n",
    "  selling_price,\n",
    "  discounted_price,\n",
    "  content_review_count,\n",
    "  content_review_wth_media_count,\n",
    "  content_rate_count,\n",
    "  content_rate_avg\n",
    "FROM 'content/price_rate_review_data.parquet';\n",
    "\n",
    "CREATE OR REPLACE VIEW content_sitewide AS SELECT \n",
    "  content_id_hashed,\n",
    "  CAST(date AS DATE) AS d,\n",
    "  total_click,\n",
    "  total_cart,\n",
    "  total_fav,\n",
    "  total_order\n",
    "FROM 'content/sitewide_log.parquet';\n",
    "\n",
    "CREATE OR REPLACE VIEW content_search AS SELECT \n",
    "  content_id_hashed,\n",
    "  CAST(date AS DATE) AS d,\n",
    "  total_search_impression,\n",
    "  total_search_click\n",
    "FROM 'content/search_log.parquet';\n",
    "\n",
    "CREATE OR REPLACE VIEW user_meta AS SELECT \n",
    "  user_id_hashed,\n",
    "  user_gender,\n",
    "  user_birth_year,\n",
    "  user_tenure_in_days\n",
    "FROM 'user/metadata.parquet';\n",
    "\n",
    "CREATE OR REPLACE VIEW user_sitewide AS SELECT \n",
    "  user_id_hashed,\n",
    "  CAST(ts_hour AS TIMESTAMP) AS ts,\n",
    "  total_click,\n",
    "  total_cart,\n",
    "  total_fav,\n",
    "  total_order\n",
    "FROM 'user/sitewide_log.parquet';\n",
    "\n",
    "CREATE OR REPLACE VIEW term_search AS SELECT \n",
    "  CAST(ts_hour AS TIMESTAMP) AS ts,\n",
    "  search_term_normalized,\n",
    "  total_search_impression,\n",
    "  total_search_click\n",
    "FROM 'term/search_log.parquet';\n",
    "\"\"\")\n",
    "\n",
    "# 3) Agregasyon tabloları\n",
    "print(\"[duckdb] Özet tablolar oluşturuluyor...\")\n",
    "\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE TABLE agg_content_all AS\n",
    "SELECT\n",
    "  content_id_hashed,\n",
    "  AVG(total_click)  AS c_click_mean,\n",
    "  AVG(total_order)  AS c_order_mean,\n",
    "  SUM(total_order)  AS c_order_sum,\n",
    "  AVG(total_fav)    AS c_fav_mean,\n",
    "  AVG(total_cart)   AS c_cart_mean\n",
    "FROM content_sitewide\n",
    "GROUP BY 1;\n",
    "\"\"\")\n",
    "\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE TABLE agg_content_recent AS\n",
    "WITH mx AS (\n",
    "  SELECT content_id_hashed, MAX(d) AS max_d FROM content_sitewide GROUP BY 1\n",
    "),\n",
    "win AS (\n",
    "  SELECT s.* FROM content_sitewide s JOIN mx USING(content_id_hashed)\n",
    "  WHERE s.d >= max_d - INTERVAL 30 DAY\n",
    ")\n",
    "SELECT\n",
    "  content_id_hashed,\n",
    "  AVG(total_click) AS c_r30_click_mean,\n",
    "  AVG(total_order) AS c_r30_order_mean,\n",
    "  SUM(total_order) AS c_r30_order_sum\n",
    "FROM win\n",
    "GROUP BY 1;\n",
    "\"\"\")\n",
    "\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE TABLE agg_content_search AS\n",
    "SELECT\n",
    "  content_id_hashed,\n",
    "  SUM(total_search_impression) AS c_imp_sum,\n",
    "  SUM(total_search_click)     AS c_clk_sum,\n",
    "  CASE WHEN SUM(total_search_impression) > 0\n",
    "       THEN SUM(total_search_click) / SUM(total_search_impression)\n",
    "       ELSE NULL END AS c_ctr\n",
    "FROM content_search\n",
    "GROUP BY 1;\n",
    "\"\"\")\n",
    "\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE TABLE latest_price AS\n",
    "SELECT * FROM (\n",
    "  SELECT *, ROW_NUMBER() OVER (PARTITION BY content_id_hashed ORDER BY update_ts DESC) AS rn\n",
    "  FROM price_reviews\n",
    ") WHERE rn=1;\n",
    "\"\"\")\n",
    "\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE TABLE price_features AS\n",
    "SELECT\n",
    "  content_id_hashed,\n",
    "  original_price,\n",
    "  selling_price,\n",
    "  discounted_price,\n",
    "  content_rate_avg,\n",
    "  content_rate_count,\n",
    "  content_review_count,\n",
    "  content_review_wth_media_count,\n",
    "  CASE WHEN original_price IS NOT NULL AND original_price > 0\n",
    "       THEN (original_price - COALESCE(discounted_price, selling_price)) / original_price\n",
    "       ELSE NULL END AS discount_pct\n",
    "FROM latest_price;\n",
    "\"\"\")\n",
    "\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE TABLE agg_user AS\n",
    "SELECT\n",
    "  user_id_hashed,\n",
    "  AVG(total_click)  AS u_click_mean,\n",
    "  AVG(total_cart)   AS u_cart_mean,\n",
    "  AVG(total_fav)    AS u_fav_mean,\n",
    "  AVG(total_order)  AS u_order_mean\n",
    "FROM user_sitewide\n",
    "GROUP BY 1;\n",
    "\"\"\")\n",
    "\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE TABLE agg_term AS\n",
    "SELECT\n",
    "  search_term_normalized,\n",
    "  SUM(total_search_impression) AS t_imp_sum,\n",
    "  SUM(total_search_click)     AS t_clk_sum,\n",
    "  CASE WHEN SUM(total_search_impression) > 0\n",
    "       THEN SUM(total_search_click) / SUM(total_search_impression)\n",
    "       ELSE NULL END AS t_ctr\n",
    "FROM term_search\n",
    "GROUP BY 1;\n",
    "\"\"\")\n",
    "\n",
    "# 4) Eğitim tablosu\n",
    "print(\"[duckdb] Eğitim tablosu hazırlanıyor...\")\n",
    "train_df = con.execute(\"\"\"\n",
    "SELECT \n",
    "  t.session_id,\n",
    "  CAST(t.ts_hour AS TIMESTAMP) AS ts_hour,\n",
    "  t.search_term_normalized,\n",
    "  t.user_id_hashed,\n",
    "  t.content_id_hashed,\n",
    "  t.clicked,\n",
    "  t.ordered,\n",
    "\n",
    "  -- ürün özetleri\n",
    "  a.c_click_mean, a.c_order_mean, a.c_order_sum, a.c_fav_mean, a.c_cart_mean,\n",
    "  r.c_r30_click_mean, r.c_r30_order_mean, r.c_r30_order_sum,\n",
    "  s.c_imp_sum, s.c_clk_sum, s.c_ctr,\n",
    "\n",
    "  -- fiyat/puan\n",
    "  p.original_price, p.selling_price, p.discounted_price, p.discount_pct,\n",
    "  p.content_rate_avg, p.content_rate_count, p.content_review_count, p.content_review_wth_media_count,\n",
    "\n",
    "  -- kullanıcı özetleri\n",
    "  u.u_click_mean, u.u_cart_mean, u.u_fav_mean, u.u_order_mean,\n",
    "\n",
    "  -- terim özetleri\n",
    "  tm.t_imp_sum, tm.t_clk_sum, tm.t_ctr,\n",
    "\n",
    "  -- meta\n",
    "  m.attribute_type_count, m.total_attribute_option_count, m.merchant_count, m.filterable_label_count,\n",
    "  m.content_creation_ts,\n",
    "\n",
    "  -- türev: içerik yaş\n",
    "  DATE_DIFF('day', m.content_creation_ts, CAST(t.ts_hour AS TIMESTAMP)) AS days_since_creation\n",
    "FROM train_sessions t\n",
    "LEFT JOIN agg_content_all a     USING(content_id_hashed)\n",
    "LEFT JOIN agg_content_recent r  USING(content_id_hashed)\n",
    "LEFT JOIN agg_content_search s  USING(content_id_hashed)\n",
    "LEFT JOIN price_features p      USING(content_id_hashed)\n",
    "LEFT JOIN agg_user u            USING(user_id_hashed)\n",
    "LEFT JOIN agg_term tm           USING(search_term_normalized)\n",
    "LEFT JOIN content_meta m        USING(content_id_hashed)\n",
    "\"\"\").df()\n",
    "\n",
    "memory_info(train_df, \"train_df (joined)\")\n",
    "\n",
    "# Zamansal parçalar + downcast\n",
    "train_df = add_time_parts(train_df, \"ts_hour\")\n",
    "for c in train_df.select_dtypes(include=[\"float64\"]).columns:\n",
    "    train_df[c] = train_df[c].astype(\"float32\")\n",
    "for c in train_df.select_dtypes(include=[\"int64\",\"Int64\"]).columns:\n",
    "    if c not in [\"clicked\", \"ordered\"]:\n",
    "        if train_df[c].isna().any():\n",
    "            train_df[c] = train_df[c].astype(\"Int32\")\n",
    "        else:\n",
    "            train_df[c] = train_df[c].astype(\"int32\")\n",
    "\n",
    "# discount_pct NaN-safe [0,1] clip\n",
    "if \"discount_pct\" in train_df.columns:\n",
    "    train_df[\"discount_pct\"] = safe_clip01(train_df[\"discount_pct\"].astype(\"float32\"))\n",
    "\n",
    "# Ek özellikler\n",
    "for col in [\"original_price\",\"selling_price\",\"discounted_price\",\n",
    "            \"content_rate_count\",\"content_review_count\",\"t_imp_sum\",\"t_clk_sum\",\n",
    "            \"c_imp_sum\",\"c_clk_sum\"]:\n",
    "    if col in train_df.columns:\n",
    "        train_df[f\"log1p_{col}\"] = np.log1p(train_df[col].fillna(0)).astype(\"float32\")\n",
    "\n",
    "EPS = 1e-6\n",
    "if {\"c_order_mean\",\"c_click_mean\"}.issubset(train_df.columns):\n",
    "    train_df[\"c_ord_per_click\"] = (train_df[\"c_order_mean\"]/(train_df[\"c_click_mean\"]+EPS)).astype(\"float32\")\n",
    "if {\"u_order_mean\",\"u_click_mean\"}.issubset(train_df.columns):\n",
    "    train_df[\"u_ord_per_click\"] = (train_df[\"u_order_mean\"]/(train_df[\"u_click_mean\"]+EPS)).astype(\"float32\")\n",
    "if {\"c_clk_sum\",\"c_imp_sum\"}.issubset(train_df.columns) and \"c_ctr\" in train_df.columns:\n",
    "    train_df[\"c_ctr_smooth\"] = ((train_df[\"c_clk_sum\"]+1)/(train_df[\"c_imp_sum\"]+2)).astype(\"float32\")\n",
    "if {\"t_clk_sum\",\"t_imp_sum\"}.issubset(train_df.columns) and \"t_ctr\" in train_df.columns:\n",
    "    train_df[\"t_ctr_smooth\"] = ((train_df[\"t_clk_sum\"]+1)/(train_df[\"t_imp_sum\"]+2)).astype(\"float32\")\n",
    "\n",
    "if \"discount_pct\" in train_df.columns:\n",
    "    train_df[\"has_discount\"] = (train_df[\"discount_pct\"].fillna(-1) > 0).astype(\"int8\")\n",
    "\n",
    "for col in [\"original_price\",\"selling_price\",\"discounted_price\",\n",
    "            \"content_rate_avg\",\"content_rate_count\",\"content_review_count\",\n",
    "            \"content_review_wth_media_count\"]:\n",
    "    if col in train_df.columns:\n",
    "        train_df[f\"isna_{col}\"] = train_df[col].isna().astype(\"int8\")\n",
    "\n",
    "memory_info(train_df, \"train_df (+engineered)\")\n",
    "\n",
    "# 5) Kategorik kodlama ve feature listesi\n",
    "cat_cols = [\"search_term_normalized\", \"user_id_hashed\", \"content_id_hashed\"]\n",
    "train_df, encoders = label_encode_train_and_map(train_df, cat_cols)\n",
    "\n",
    "drop_cols = [\"session_id\", \"ts_hour\", \"clicked\", \"ordered\", \"content_creation_ts\"]\n",
    "features = [c for c in train_df.columns if c not in drop_cols]\n",
    "from pandas.api.types import is_datetime64_any_dtype\n",
    "_dt_cols = [c for c in features if is_datetime64_any_dtype(train_df[c])]\n",
    "if _dt_cols:\n",
    "    print(\"[feat] dropping datetime cols:\", _dt_cols)\n",
    "    features = [c for c in features if c not in _dt_cols]\n",
    "print(f\"[feat] {len(features)} feature kullanılacak\")\n",
    "\n",
    "# 6) Eğitim – LGBM categorical + pos_weight + OOF blend tuning\n",
    "cat_cols_model = [\"search_term_normalized\", \"user_id_hashed\", \"content_id_hashed\"]\n",
    "\n",
    "X = train_df[features].copy()\n",
    "for c in cat_cols_model:\n",
    "    if c in X.columns: X[c] = X[c].astype(\"int32\")\n",
    "for c in [col for col in X.columns if col not in cat_cols_model]:\n",
    "    if pd.api.types.is_numeric_dtype(X[c]): X[c] = X[c].astype(\"float32\")\n",
    "\n",
    "y_click = train_df[\"clicked\"].astype(int)\n",
    "y_order = train_df[\"ordered\"].astype(int)\n",
    "groups  = train_df[\"session_id\"].values\n",
    "\n",
    "# ---- Hızlı ve düzenli parametreler ----\n",
    "base_params = dict(\n",
    "    objective=\"binary\",\n",
    "    metric=\"auc\",\n",
    "    learning_rate=0.05,\n",
    "    num_leaves=48,\n",
    "    min_data_in_leaf=300,\n",
    "    lambda_l2=1.0,\n",
    "    feature_fraction=0.75,\n",
    "    bagging_fraction=0.75,\n",
    "    bagging_freq=1,\n",
    "    max_bin=191,\n",
    "    verbosity=-1,\n",
    "    seed=RANDOM_STATE,\n",
    "    num_threads=os.cpu_count(),\n",
    ")\n",
    "\n",
    "def neg_pos_weight(y):\n",
    "    pos = int(y.sum()); neg = int(len(y) - pos)\n",
    "    return float(neg / max(1, pos))\n",
    "\n",
    "params_click = dict(base_params, scale_pos_weight=neg_pos_weight(y_click))\n",
    "params_order = dict(base_params, scale_pos_weight=neg_pos_weight(y_order))\n",
    "\n",
    "# 5 -> 3 fold (hız)\n",
    "cv = GroupKFold(n_splits=3)\n",
    "\n",
    "def fit_lgb_cv(X, y, groups, label, params, categorical_feature):\n",
    "    oof = np.zeros(len(X), dtype=np.float32)\n",
    "    models = []\n",
    "    for fold, (tr, va) in enumerate(cv.split(X, y, groups)):\n",
    "        X_tr, y_tr = X.iloc[tr], y.iloc[tr]\n",
    "        X_va, y_va = X.iloc[va], y.iloc[va]\n",
    "        l_tr = lgb.Dataset(X_tr, label=y_tr, free_raw_data=False, categorical_feature=categorical_feature)\n",
    "        l_va = lgb.Dataset(X_va, label=y_va, free_raw_data=False, categorical_feature=categorical_feature)\n",
    "        print(f\"[lgb] {label} fold {fold}\")\n",
    "        model = lgb.train(\n",
    "            params,\n",
    "            l_tr,\n",
    "            valid_sets=[l_tr, l_va],\n",
    "            valid_names=[\"train\", \"valid\"],\n",
    "            num_boost_round=1500,\n",
    "            callbacks=[\n",
    "                lgb.early_stopping(stopping_rounds=100),\n",
    "                lgb.log_evaluation(period=200),\n",
    "            ],\n",
    "        )\n",
    "        models.append(model)\n",
    "        oof[va] = model.predict(X_va, num_iteration=model.best_iteration)\n",
    "    return models, oof\n",
    "\n",
    "click_models, oof_click = fit_lgb_cv(X, y_click, groups, label=\"clicked\",\n",
    "                                     params=params_click, categorical_feature=cat_cols_model)\n",
    "order_models, oof_order = fit_lgb_cv(X, y_order, groups, label=\"ordered\",\n",
    "                                     params=params_order, categorical_feature=cat_cols_model)\n",
    "\n",
    "# OOF üzerinde blend ağırlığı taraması\n",
    "grid = np.linspace(0.55, 0.90, 8)\n",
    "best_w, best_score = None, -1.0\n",
    "for w in grid:\n",
    "    s = w*oof_order + (1.0 - w)*oof_click\n",
    "    auc_o = roc_auc_score(y_order, s)\n",
    "    auc_c = roc_auc_score(y_click, s)\n",
    "    score = 0.7*auc_o + 0.3*auc_c\n",
    "    print(f\"[blend] w={w:.2f}  auc_order={auc_o:.6f}  auc_click={auc_c:.6f}  score={score:.6f}\")\n",
    "    if score > best_score:\n",
    "        best_score, best_w = score, float(w)\n",
    "print(f\"[blend] BEST w={best_w:.3f}  score={best_score:.6f}\")\n",
    "BLEND_W = best_w\n",
    "\n",
    "oof_final = BLEND_W*oof_order + (1.0-BLEND_W)*oof_click\n",
    "print(\"[info] OOF özet:\")\n",
    "print(pd.Series(oof_final).describe())\n",
    "\n",
    "# 7) Test batch akışı (carry-over + merge)\n",
    "def fetch_test_batch(offset: int, limit: int = 2_000_000):\n",
    "    q = f\"\"\"\n",
    "    SELECT \n",
    "      t.session_id,\n",
    "      CAST(t.ts_hour AS TIMESTAMP) AS ts_hour,\n",
    "      t.search_term_normalized,\n",
    "      t.user_id_hashed,\n",
    "      t.content_id_hashed,\n",
    "\n",
    "      a.c_click_mean, a.c_order_mean, a.c_order_sum, a.c_fav_mean, a.c_cart_mean,\n",
    "      r.c_r30_click_mean, r.c_r30_order_mean, r.c_r30_order_sum,\n",
    "      s.c_imp_sum, s.c_clk_sum, s.c_ctr,\n",
    "\n",
    "      p.original_price, p.selling_price, p.discounted_price, p.discount_pct,\n",
    "      p.content_rate_avg, p.content_rate_count, p.content_review_count, p.content_review_wth_media_count,\n",
    "\n",
    "      u.u_click_mean, u.u_cart_mean, u.u_fav_mean, u.u_order_mean,\n",
    "\n",
    "      tm.t_imp_sum, tm.t_clk_sum, tm.t_ctr,\n",
    "\n",
    "      m.attribute_type_count, m.total_attribute_option_count, m.merchant_count, m.filterable_label_count,\n",
    "      m.content_creation_ts,\n",
    "\n",
    "      DATE_DIFF('day', m.content_creation_ts, CAST(t.ts_hour AS TIMESTAMP)) AS days_since_creation\n",
    "    FROM test_sessions t\n",
    "    LEFT JOIN agg_content_all a     USING(content_id_hashed)\n",
    "    LEFT JOIN agg_content_recent r  USING(content_id_hashed)\n",
    "    LEFT JOIN agg_content_search s  USING(content_id_hashed)\n",
    "    LEFT JOIN price_features p      USING(content_id_hashed)\n",
    "    LEFT JOIN agg_user u            USING(user_id_hashed)\n",
    "    LEFT JOIN agg_term tm           USING(search_term_normalized)\n",
    "    LEFT JOIN content_meta m        USING(content_id_hashed)\n",
    "    ORDER BY t.session_id, t.content_id_hashed\n",
    "    LIMIT {limit} OFFSET {offset}\n",
    "    \"\"\"\n",
    "    return con.execute(q).df()\n",
    "\n",
    "def encode_and_timeparts(df: pd.DataFrame):\n",
    "    df = add_time_parts(df, \"ts_hour\")\n",
    "    # Ham ID'yi submission için sakla\n",
    "    if \"content_id_hashed\" in df.columns and \"content_id_raw\" not in df.columns:\n",
    "        df[\"content_id_raw\"] = df[\"content_id_hashed\"].astype(str)\n",
    "    # downcast\n",
    "    for c in df.select_dtypes(include=[\"float64\"]).columns:\n",
    "        df[c] = df[c].astype(\"float32\")\n",
    "    for c in df.select_dtypes(include=[\"int64\",\"Int64\"]).columns:\n",
    "        if c not in [\"clicked\", \"ordered\"]:\n",
    "            if df[c].isna().any():\n",
    "                df[c] = df[c].astype(\"Int32\")\n",
    "            else:\n",
    "                df[c] = df[c].astype(\"int32\")\n",
    "\n",
    "    # discount_pct NaN-safe [0,1] clip\n",
    "    if \"discount_pct\" in df.columns:\n",
    "        df[\"discount_pct\"] = safe_clip01(df[\"discount_pct\"].astype(\"float32\"))\n",
    "\n",
    "    # engineered test features\n",
    "    for col in [\"original_price\",\"selling_price\",\"discounted_price\",\n",
    "                \"content_rate_count\",\"content_review_count\",\"t_imp_sum\",\"t_clk_sum\",\n",
    "                \"c_imp_sum\",\"c_clk_sum\"]:\n",
    "        if col in df.columns:\n",
    "            df[f\"log1p_{col}\"] = np.log1p(df[col].fillna(0)).astype(\"float32\")\n",
    "    EPS = 1e-6\n",
    "    if {\"c_order_mean\",\"c_click_mean\"}.issubset(df.columns):\n",
    "        df[\"c_ord_per_click\"] = (df[\"c_order_mean\"]/(df[\"c_click_mean\"]+EPS)).astype(\"float32\")\n",
    "    if {\"u_order_mean\",\"u_click_mean\"}.issubset(df.columns):\n",
    "        df[\"u_ord_per_click\"] = (df[\"u_order_mean\"]/(df[\"u_click_mean\"]+EPS)).astype(\"float32\")\n",
    "    if {\"c_clk_sum\",\"c_imp_sum\"}.issubset(df.columns) and \"c_ctr\" in df.columns:\n",
    "        df[\"c_ctr_smooth\"] = ((df[\"c_clk_sum\"]+1)/(df[\"c_imp_sum\"]+2)).astype(\"float32\")\n",
    "    if {\"t_clk_sum\",\"t_imp_sum\"}.issubset(df.columns) and \"t_ctr\" in df.columns:\n",
    "        df[\"t_ctr_smooth\"] = ((df[\"t_clk_sum\"]+1)/(df[\"t_imp_sum\"]+2)).astype(\"float32\")\n",
    "    if \"discount_pct\" in df.columns:\n",
    "        df[\"has_discount\"] = (df[\"discount_pct\"].fillna(-1) > 0).astype(\"int8\")\n",
    "    for col in [\"original_price\",\"selling_price\",\"discounted_price\",\n",
    "                \"content_rate_avg\",\"content_rate_count\",\"content_review_count\",\n",
    "                \"content_review_wth_media_count\"]:\n",
    "        if col in df.columns:\n",
    "            df[f\"isna_{col}\"] = df[col].isna().astype(\"int8\")\n",
    "\n",
    "    # label encode\n",
    "    df = label_encode_apply(df, encoders)\n",
    "    return df\n",
    "\n",
    "def predict_batch(df: pd.DataFrame):\n",
    "    from pandas.api.types import is_datetime64_any_dtype\n",
    "    id_col = \"content_id_raw\" if \"content_id_raw\" in df.columns else \"content_id_hashed\"\n",
    "    drop_cols_pred = {\"session_id\",\"ts_hour\",\"content_creation_ts\", id_col}\n",
    "    cols = [c for c in df.columns if c not in drop_cols_pred]\n",
    "    Xb = df[cols].copy()\n",
    "    # datetime'ları at\n",
    "    dt_cols = [c for c in Xb.columns if is_datetime64_any_dtype(Xb[c])]\n",
    "    if dt_cols: Xb = Xb.drop(columns=dt_cols)\n",
    "    # dtypes\n",
    "    for c in cat_cols_model:\n",
    "        if c in Xb.columns: Xb[c] = Xb[c].astype(\"int32\")\n",
    "    for c in [col for col in Xb.columns if col not in cat_cols_model]:\n",
    "        if pd.api.types.is_numeric_dtype(Xb[c]): Xb[c] = Xb[c].astype(\"float32\")\n",
    "    # predict\n",
    "    p_click = np.mean([m.predict(Xb, num_iteration=m.best_iteration) for m in click_models], axis=0)\n",
    "    p_order = np.mean([m.predict(Xb, num_iteration=m.best_iteration) for m in order_models], axis=0)\n",
    "    final = BLEND_W*p_order + (1.0-BLEND_W)*p_click\n",
    "    return pd.DataFrame({\n",
    "        \"session_id\": df[\"session_id\"].astype(str).values,\n",
    "        \"content_id\": df[id_col].astype(str).values,\n",
    "        \"final_score\": final.astype(\"float32\"),\n",
    "    })\n",
    "\n",
    "print(\"[sanity] helpers ready\")\n",
    "\n",
    "# Batch döngüsü (carry-over ile session bölünmesini engelle)\n",
    "parts = []\n",
    "offset = 0\n",
    "limit = 2_000_000\n",
    "leftover = pd.DataFrame()\n",
    "\n",
    "while True:\n",
    "    t0 = time.time()\n",
    "    tb = fetch_test_batch(offset, limit)\n",
    "    if len(tb) == 0:\n",
    "        break\n",
    "\n",
    "    if not leftover.empty:\n",
    "        tb = pd.concat([leftover, tb], ignore_index=True)\n",
    "        leftover = pd.DataFrame()\n",
    "\n",
    "    tb = tb.sort_values([\"session_id\"], kind=\"mergesort\").reset_index(drop=True)\n",
    "    last_sid = tb[\"session_id\"].iloc[-1]\n",
    "    mask_last = (tb[\"session_id\"] == last_sid)\n",
    "\n",
    "    current  = tb.loc[~mask_last].copy()\n",
    "    leftover = tb.loc[mask_last].copy()\n",
    "\n",
    "    if not current.empty:\n",
    "        current = encode_and_timeparts(current)\n",
    "        pb = predict_batch(current)\n",
    "        # session bazlı sıralama string'i\n",
    "        pb = (\n",
    "            pb.sort_values([\"session_id\",\"final_score\"], ascending=[True, False])\n",
    "              .groupby(\"session_id\")[\"content_id\"]\n",
    "              .apply(lambda s: \" \".join(s.astype(str)))\n",
    "              .reset_index(name=\"prediction\")\n",
    "        )\n",
    "        part_path = f\"submission_part_{offset}.csv\"\n",
    "        pb.to_csv(part_path, index=False)\n",
    "        parts.append(part_path)\n",
    "        dt = time.time() - t0\n",
    "        print(f\"[batch] written {part_path} in {dt:.1f}s rows={len(current)}\")\n",
    "        del current, pb\n",
    "        gc.collect()\n",
    "\n",
    "    offset += limit\n",
    "    del tb\n",
    "    gc.collect()\n",
    "\n",
    "# Son kuyruk\n",
    "if not leftover.empty:\n",
    "    print(f\"[batch] processing leftover rows={len(leftover)}\")\n",
    "    current = encode_and_timeparts(leftover)\n",
    "    pb = predict_batch(current)\n",
    "    pb = (\n",
    "        pb.sort_values([\"session_id\",\"final_score\"], ascending=[True, False])\n",
    "          .groupby(\"session_id\")[\"content_id\"]\n",
    "          .apply(lambda s: \" \".join(s.astype(str)))\n",
    "          .reset_index(name=\"prediction\")\n",
    "    )\n",
    "    part_path = \"submission_part_tail.csv\"\n",
    "    pb.to_csv(part_path, index=False)\n",
    "    parts.append(part_path)\n",
    "    del leftover, current, pb\n",
    "    gc.collect()\n",
    "\n",
    "# Merge + dedup (her session_id için tek satır)\n",
    "if not parts:\n",
    "    raise RuntimeError(\"Test partları oluşmadı. Test dosyası boş olabilir.\")\n",
    "\n",
    "print(\"[merge] Parçalar birleştiriliyor…\")\n",
    "con.execute(\"CREATE OR REPLACE TABLE subs(partition INT, session_id VARCHAR, prediction VARCHAR);\")\n",
    "for i, pth in enumerate(parts):\n",
    "    con.execute(\"INSERT INTO subs SELECT ?, * FROM read_csv_auto(?, HEADER=TRUE)\", [i, pth])\n",
    "\n",
    "submission = con.execute(\"\"\"\n",
    "    WITH ranked AS (\n",
    "      SELECT partition, session_id, prediction,\n",
    "             ROW_NUMBER() OVER (PARTITION BY session_id ORDER BY partition DESC) AS rn\n",
    "      FROM subs\n",
    "    )\n",
    "    SELECT session_id, prediction\n",
    "    FROM ranked\n",
    "    WHERE rn = 1\n",
    "\"\"\").df().sort_values(\"session_id\").reset_index(drop=True)\n",
    "\n",
    "submission_path = \"submission.csv\"\n",
    "submission.to_csv(submission_path, index=False)\n",
    "\n",
    "# Sanity kontrol: benzersiz session sayısı\n",
    "n_expected = con.execute(\"SELECT COUNT(DISTINCT session_id) FROM test_sessions\").fetchone()[0]\n",
    "print(f\"[sanity] uniq_session_in_submission={submission['session_id'].nunique()} expected={n_expected}\")\n",
    "print(f\"[done] submission yazıldı: {submission_path}, satır sayısı = {len(submission)} + başlık\")\n",
    "\n",
    "print(\"[check] İlk 3 satır:\")\n",
    "print(submission.head(3))\n",
    "\n",
    "print(\"\\nKaggle'a gönderim için:\")\n",
    "print(\"kaggle competitions submit -c trendyol-e-ticaret-hackathonu-2025-kaggle -f submission.csv -m \\\"LGBM (cats+posw) + engineered feats + tuned blend (NaN-safe clip, fast CV)\\\"\")\n"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "datasetId": 8073218,
     "sourceId": 12770585,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 31089,
   "isGpuEnabled": false,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.13"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 874.602125,
   "end_time": "2025-08-18T12:27:36.115219",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-08-18T12:13:01.513094",
   "version": "2.6.0"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {
     "10dae097117f4506ad42da92c0113bbc": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_43a98f77ad874661a4570dc47e6c8ddd",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_b1127bf5675c43feb7cd7ca534c3e1f7",
       "tabbable": null,
       "tooltip": null,
       "value": 100.0
      }
     },
     "1557515a18b24cd4adcd8c7ba3a03012": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "auto"
      }
     },
     "19fd69339f2c45ffb65b84564df441f6": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "auto"
      }
     },
     "266751a9ef414bbf8e98e139c9721b98": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": "black",
       "description_width": ""
      }
     },
     "43a98f77ad874661a4570dc47e6c8ddd": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "auto"
      }
     },
     "4cbabc9df11d48e68a01621161dae248": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "auto"
      }
     },
     "4f990ee90d924aef9e0fa5fdbb9a500c": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": "black",
       "description_width": ""
      }
     },
     "5d22adc8a5f440ec819d43c916c4e45f": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_1557515a18b24cd4adcd8c7ba3a03012",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_9d8c8f4f03fa4e199f9abbec682c65e8",
       "tabbable": null,
       "tooltip": null,
       "value": 100.0
      }
     },
     "60f009a6e84a4132824287b6dd71cd06": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_79be9062b4a1437a82cf7793e59f2e6e",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_beef59f32b604635a97d86fee8668354",
       "tabbable": null,
       "tooltip": null,
       "value": 100.0
      }
     },
     "76da190758bd421ebdb101fa095c402b": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_8b05c2db61504b9bbb8e9f37b9217145",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_266751a9ef414bbf8e98e139c9721b98",
       "tabbable": null,
       "tooltip": null,
       "value": 100.0
      }
     },
     "79be9062b4a1437a82cf7793e59f2e6e": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "auto"
      }
     },
     "7ffd38a2774546ea95a0955e38ad1d67": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": "black",
       "description_width": ""
      }
     },
     "80078e6161954179b3092443dae97097": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "auto"
      }
     },
     "828d7acce2494d4f958f2e9141a195d8": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_4cbabc9df11d48e68a01621161dae248",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_b319a8a312f648c5aa74dae34920844a",
       "tabbable": null,
       "tooltip": null,
       "value": 100.0
      }
     },
     "8b05c2db61504b9bbb8e9f37b9217145": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "auto"
      }
     },
     "9d8c8f4f03fa4e199f9abbec682c65e8": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": "black",
       "description_width": ""
      }
     },
     "b1127bf5675c43feb7cd7ca534c3e1f7": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": "black",
       "description_width": ""
      }
     },
     "b319a8a312f648c5aa74dae34920844a": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": "black",
       "description_width": ""
      }
     },
     "b9bc83fb039c4610bc4c0d94cda5c37f": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_80078e6161954179b3092443dae97097",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_7ffd38a2774546ea95a0955e38ad1d67",
       "tabbable": null,
       "tooltip": null,
       "value": 100.0
      }
     },
     "beef59f32b604635a97d86fee8668354": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": "black",
       "description_width": ""
      }
     },
     "f6be474f31a04b0398c186e689bd767a": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_19fd69339f2c45ffb65b84564df441f6",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_4f990ee90d924aef9e0fa5fdbb9a500c",
       "tabbable": null,
       "tooltip": null,
       "value": 100.0
      }
     }
    },
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
