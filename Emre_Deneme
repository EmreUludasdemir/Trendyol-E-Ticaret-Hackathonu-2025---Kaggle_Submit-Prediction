{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "4b7448f3",
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "execution": {
     "iopub.execute_input": "2025-08-18T07:16:43.767911Z",
     "iopub.status.busy": "2025-08-18T07:16:43.767524Z",
     "iopub.status.idle": "2025-08-18T07:41:58.252917Z",
     "shell.execute_reply": "2025-08-18T07:41:58.251625Z"
    },
    "papermill": {
     "duration": 1514.493413,
     "end_time": "2025-08-18T07:41:58.255806",
     "exception": false,
     "start_time": "2025-08-18T07:16:43.762393",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[link] train_sessions.parquet -> /kaggle/input/trendyol/data/train_sessions.parquet\n",
      "[link] test_sessions.parquet -> /kaggle/input/trendyol/data/test_sessions.parquet\n",
      "[link] content/metadata.parquet -> /kaggle/input/trendyol/data/content/metadata.parquet\n",
      "[link] content/price_rate_review_data.parquet -> /kaggle/input/trendyol/data/content/price_rate_review_data.parquet\n",
      "[link] content/search_log.parquet -> /kaggle/input/trendyol/data/content/search_log.parquet\n",
      "[link] content/sitewide_log.parquet -> /kaggle/input/trendyol/data/content/sitewide_log.parquet\n",
      "[link] user/metadata.parquet -> /kaggle/input/trendyol/data/user/metadata.parquet\n",
      "[link] user/sitewide_log.parquet -> /kaggle/input/trendyol/data/user/sitewide_log.parquet\n",
      "[link] term/search_log.parquet -> /kaggle/input/trendyol/data/term/search_log.parquet\n",
      "[duckdb] View'lar oluşturuluyor...\n",
      "[duckdb] Özet tablolar oluşturuluyor...\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "5474438d24754842917f82515657d63e",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "FloatProgress(value=0.0, layout=Layout(width='auto'), style=ProgressStyle(bar_color='black'))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "31c37900087a48f1b4f35c8b443c8690",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "FloatProgress(value=0.0, layout=Layout(width='auto'), style=ProgressStyle(bar_color='black'))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "cd8a722c47594b898875854aba237cdb",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "FloatProgress(value=0.0, layout=Layout(width='auto'), style=ProgressStyle(bar_color='black'))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[duckdb] Eğitim tablosu hazırlanıyor...\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "260930d1453d4dc48516bba0188e20ee",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "FloatProgress(value=0.0, layout=Layout(width='auto'), style=ProgressStyle(bar_color='black'))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[mem] train_df (joined): 1518.39 MB, shape=(2773805, 39)\n",
      "[mem] train_df (typed): 1219.47 MB, shape=(2773805, 43)\n",
      "[feat] 38 feature kullanılacak\n",
      "[lgb] clicked fold 0\n",
      "Training until validation scores don't improve for 150 rounds\n",
      "[200]\ttrain's auc: 0.748103\tvalid's auc: 0.665326\n",
      "Early stopping, best iteration is:\n",
      "[123]\ttrain's auc: 0.723831\tvalid's auc: 0.665408\n",
      "[lgb] clicked fold 1\n",
      "Training until validation scores don't improve for 150 rounds\n",
      "[200]\ttrain's auc: 0.749726\tvalid's auc: 0.65564\n",
      "Early stopping, best iteration is:\n",
      "[94]\ttrain's auc: 0.714233\tvalid's auc: 0.656858\n",
      "[lgb] clicked fold 2\n",
      "Training until validation scores don't improve for 150 rounds\n",
      "[200]\ttrain's auc: 0.750679\tvalid's auc: 0.660142\n",
      "Early stopping, best iteration is:\n",
      "[68]\ttrain's auc: 0.701521\tvalid's auc: 0.661308\n",
      "[lgb] clicked fold 3\n",
      "Training until validation scores don't improve for 150 rounds\n",
      "[200]\ttrain's auc: 0.750274\tvalid's auc: 0.658655\n",
      "Early stopping, best iteration is:\n",
      "[117]\ttrain's auc: 0.723696\tvalid's auc: 0.660195\n",
      "[lgb] clicked fold 4\n",
      "Training until validation scores don't improve for 150 rounds\n",
      "[200]\ttrain's auc: 0.750473\tvalid's auc: 0.653837\n",
      "Early stopping, best iteration is:\n",
      "[69]\ttrain's auc: 0.702547\tvalid's auc: 0.654957\n",
      "[lgb] ordered fold 0\n",
      "Training until validation scores don't improve for 150 rounds\n",
      "[200]\ttrain's auc: 0.973522\tvalid's auc: 0.762355\n",
      "Early stopping, best iteration is:\n",
      "[113]\ttrain's auc: 0.939029\tvalid's auc: 0.763464\n",
      "[lgb] ordered fold 1\n",
      "Training until validation scores don't improve for 150 rounds\n",
      "[200]\ttrain's auc: 0.973485\tvalid's auc: 0.75404\n",
      "Early stopping, best iteration is:\n",
      "[177]\ttrain's auc: 0.967525\tvalid's auc: 0.755897\n",
      "[lgb] ordered fold 2\n",
      "Training until validation scores don't improve for 150 rounds\n",
      "[200]\ttrain's auc: 0.973437\tvalid's auc: 0.74967\n",
      "Early stopping, best iteration is:\n",
      "[60]\ttrain's auc: 0.88801\tvalid's auc: 0.750729\n",
      "[lgb] ordered fold 3\n",
      "Training until validation scores don't improve for 150 rounds\n",
      "[200]\ttrain's auc: 0.972261\tvalid's auc: 0.741223\n",
      "Early stopping, best iteration is:\n",
      "[69]\ttrain's auc: 0.899978\tvalid's auc: 0.744064\n",
      "[lgb] ordered fold 4\n",
      "Training until validation scores don't improve for 150 rounds\n",
      "[200]\ttrain's auc: 0.972397\tvalid's auc: 0.754317\n",
      "Early stopping, best iteration is:\n",
      "[75]\ttrain's auc: 0.905695\tvalid's auc: 0.756951\n",
      "[info] OOF özet:\n",
      "count    2.773805e+06\n",
      "mean     1.308443e-02\n",
      "std      8.299356e-03\n",
      "min      7.068094e-04\n",
      "25%      7.841692e-03\n",
      "50%      1.186381e-02\n",
      "75%      1.665653e-02\n",
      "max      4.076746e-01\n",
      "dtype: float64\n",
      "[info] feature_importance_top30.csv kaydedildi.\n",
      "[duckdb] Test veri akışı başlıyor…\n",
      "[sanity] helpers defined: True True True\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "9f3aa9e0938b446d869d3b36d00c5842",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "FloatProgress(value=0.0, layout=Layout(width='auto'), style=ProgressStyle(bar_color='black'))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[batch] written submission_part_0.csv in 101.3s rows=1999959\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "d5cb49fd4b9b4358be1c28ae1faea8ad",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "FloatProgress(value=0.0, layout=Layout(width='auto'), style=ProgressStyle(bar_color='black'))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[batch] written submission_part_2000000.csv in 53.7s rows=988622\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "f591e06733674fa9869f895785224e0f",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "FloatProgress(value=0.0, layout=Layout(width='auto'), style=ProgressStyle(bar_color='black'))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[batch] processing leftover rows=116\n",
      "[merge] Parçalar birleştiriliyor…\n",
      "[sanity] uniq_session_in_submission=18589 expected=18589\n",
      "[sanity] uniq_session_in_submission=18589 expected=18589\n",
      "[done] submission yazıldı: submission.csv, satır sayısı = 18589 + başlık\n",
      "[check] İlk 3 satır:\n",
      "              session_id                                         prediction\n",
      "0  test_0001ff614df60933  89b1a5be8f804fe7 d13c66f775662c28 510d4b141768...\n",
      "1  test_00041895a35c4813  e95b82f982466786 5b6dced01b91a9ae efb696c8df5f...\n",
      "2  test_00058d4dc9727758  532f78e69e290328 74c06f4347b553e1 f243ca14ab5e...\n",
      "\n",
      "Kaggle'a gönderim için:\n",
      "kaggle competitions submit -c trendyol-e-ticaret-hackathonu-2025-kaggle -f submission.csv -m \"LGBM + geniş özellik seti\"\n"
     ]
    }
   ],
   "source": [
    "# Kaggle Bootstrap: inputları otomatik bağla, eksik paketleri kontrol et (bu hücreyi en başta çalıştırın)\n",
    "import os, glob, shutil, sys, importlib, subprocess\n",
    "\n",
    "# 1) Paket kontrol/kurulum (internet kapalıysa çoğu zaten yüklüdür; eksikse dene)\n",
    "def ensure_packages(pkgs=(\"duckdb\",\"polars\",\"lightgbm\",\"pyarrow\")):\n",
    "    missing=[]\n",
    "    for p in pkgs:\n",
    "        try:\n",
    "            importlib.import_module(p)\n",
    "        except ImportError:\n",
    "            missing.append(p)\n",
    "    if missing:\n",
    "        try:\n",
    "            subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"-q\", *missing])\n",
    "            print(\"[pip] Yüklendi:\", missing)\n",
    "        except Exception as e:\n",
    "            print(\"[pip] Kurulum başarısız veya internet kapalı:\", missing, e)\n",
    "\n",
    "ensure_packages()\n",
    "\n",
    "# 2) Kaggle input -> çalışma dizinine beklenen isimlerle bağla (symlink/copy)\n",
    "BASE_IN = \"/kaggle/input\"\n",
    "\n",
    "expected = {\n",
    "    \"train_sessions.parquet\": [\"**/train_sessions.parquet\"],\n",
    "    \"test_sessions.parquet\":  [\"**/test_sessions.parquet\"],\n",
    "    \"content/metadata.parquet\": [\"**/content/**/metadata.parquet\", \"**/metadata.parquet\"],\n",
    "    \"content/price_rate_review_data.parquet\": [\"**/content/**/price_rate_review_data.parquet\", \"**/price_rate_review_data.parquet\"],\n",
    "    \"content/search_log.parquet\": [\"**/content/**/search_log.parquet\", \"**/search_log.parquet\"],\n",
    "    \"content/sitewide_log.parquet\": [\"**/content/**/sitewide_log.parquet\", \"**/sitewide_log.parquet\"],\n",
    "    \"user/metadata.parquet\": [\"**/user/**/metadata.parquet\", \"**/user_metadata.parquet\", \"**/user-meta.parquet\", \"**/user_metadata*.parquet\"],\n",
    "    \"user/sitewide_log.parquet\": [\"**/user/**/sitewide_log.parquet\", \"**/user_sitewide_log.parquet\"],\n",
    "    \"term/search_log.parquet\": [\"**/term/**/search_log.parquet\", \"**/term_search_log.parquet\"],\n",
    "}\n",
    "\n",
    "def ensure_link(src, dst):\n",
    "    os.makedirs(os.path.dirname(dst) or \".\", exist_ok=True)\n",
    "    if os.path.exists(dst):\n",
    "        return\n",
    "    try:\n",
    "        os.symlink(src, dst)\n",
    "        print(f\"[link] {dst} -> {src}\")\n",
    "    except Exception:\n",
    "        shutil.copy2(src, dst)\n",
    "        print(f\"[copy] {dst} <- {src}\")\n",
    "\n",
    "def map_inputs():\n",
    "    root = BASE_IN if os.path.exists(BASE_IN) else \".\"\n",
    "    for dst, patterns in expected.items():\n",
    "        found = None\n",
    "        for pat in patterns:\n",
    "            matches = glob.glob(os.path.join(root, pat), recursive=True)\n",
    "            if matches:\n",
    "                found = matches[0]\n",
    "                break\n",
    "        if not found:\n",
    "            print(f\"[WARN] Bulunamadı: {dst}. Doğru competition/dataset'i Notebook'a eklediğinizden emin olun.\")\n",
    "            continue\n",
    "        ensure_link(found, dst)\n",
    "\n",
    "map_inputs()\n",
    "\n",
    "# -*- coding: utf-8 -*-\n",
    "\"\"\"\n",
    "Trendyol E-Ticaret Hackathonu 2025\n",
    "Yüksek performanslı tahmin boru hattı\n",
    "\n",
    "Öne çıkanlar:\n",
    "- DuckDB ile büyük dosyalarda hızlı toplulaştırma ve hafif join\n",
    "- Polars/Pandas ile kontrollü dönüşüm\n",
    "- Zengin özellik seti (kullanıcı/ürün/terim + trend + fiyat/puan + zamansal)\n",
    "- clicked ve ordered için iki LightGBM modeli + ağırlıklı sıralama\n",
    "- Batch inferans ve yarışma formatında submission üretimi\n",
    "\n",
    "Dosya yapısı (aynı klasörde/uygun path’lerde beklenir):\n",
    "- train_sessions.parquet, test_sessions.parquet\n",
    "- content/metadata.parquet\n",
    "- content/price_rate_review_data.parquet\n",
    "- content/search_log.parquet\n",
    "- content/sitewide_log.parquet\n",
    "- user/metadata.parquet\n",
    "- user/sitewide_log.parquet\n",
    "- term/search_log.parquet\n",
    "\n",
    "Gereksinimler: pip install duckdb polars pandas numpy scikit-learn lightgbm pyarrow\n",
    "\"\"\"\n",
    "\n",
    "import os\n",
    "import gc\n",
    "import json\n",
    "import math\n",
    "import time\n",
    "import uuid\n",
    "import duckdb\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import polars as pl\n",
    "from datetime import datetime\n",
    "from sklearn.model_selection import GroupKFold\n",
    "from sklearn.preprocessing import LabelEncoder\n",
    "import lightgbm as lgb\n",
    "\n",
    "RANDOM_STATE = 42\n",
    "np.random.seed(RANDOM_STATE)\n",
    "\n",
    "###############################################################################\n",
    "# 0) Yardımcılar\n",
    "###############################################################################\n",
    "\n",
    "def ensure_dir(path: str):\n",
    "    d = os.path.dirname(path)\n",
    "    if d and not os.path.exists(d):\n",
    "        os.makedirs(d, exist_ok=True)\n",
    "\n",
    "\n",
    "def memory_info(df: pd.DataFrame, name: str = \"DF\"):\n",
    "    mb = df.memory_usage(deep=True).sum() / (1024**2)\n",
    "    print(f\"[mem] {name}: {mb:.2f} MB, shape={df.shape}\")\n",
    "\n",
    "\n",
    "def label_encode_train_and_map(df: pd.DataFrame, cols):\n",
    "    encoders = {}\n",
    "    for c in cols:\n",
    "        le = LabelEncoder()\n",
    "        df[c] = le.fit_transform(df[c].astype(str))\n",
    "        encoders[c] = le\n",
    "    return df, encoders\n",
    "\n",
    "\n",
    "def label_encode_apply(df: pd.DataFrame, encoders):\n",
    "    # Bilinmeyen kategorileri güvenle işle\n",
    "    for c, le in encoders.items():\n",
    "        vals = df[c].astype(str)\n",
    "        unseen = ~vals.isin(le.classes_)\n",
    "        if unseen.any():\n",
    "            # classes_’a yeni etiket ekle (None placeholder)\n",
    "            le.classes_ = np.append(le.classes_, vals[unseen].unique())\n",
    "        df[c] = le.transform(vals)\n",
    "    return df\n",
    "\n",
    "\n",
    "def add_time_parts(df: pd.DataFrame, ts_col: str = \"ts_hour\"):\n",
    "    ts = pd.to_datetime(df[ts_col], errors=\"coerce\")\n",
    "    df[\"hour\"] = ts.dt.hour.astype(\"Int16\")\n",
    "    df[\"dow\"] = ts.dt.dayofweek.astype(\"Int16\")\n",
    "    df[\"week\"] = ts.dt.isocalendar().week.astype(\"Int16\")\n",
    "    df[\"month\"] = ts.dt.month.astype(\"Int8\")\n",
    "    return df\n",
    "\n",
    "\n",
    "###############################################################################\n",
    "# 1) DuckDB bağlantısı ve View'lar\n",
    "###############################################################################\n",
    "con = duckdb.connect(database=\":memory:\")\n",
    "con.execute(\"PRAGMA threads=%d\" % os.cpu_count())\n",
    "\n",
    "print(\"[duckdb] View'lar oluşturuluyor...\")\n",
    "\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE VIEW train_sessions AS SELECT * FROM 'train_sessions.parquet';\n",
    "CREATE OR REPLACE VIEW test_sessions  AS SELECT * FROM 'test_sessions.parquet';\n",
    "\n",
    "CREATE OR REPLACE VIEW content_meta AS SELECT \n",
    "  content_id_hashed,\n",
    "  attribute_type_count,\n",
    "  total_attribute_option_count,\n",
    "  merchant_count,\n",
    "  filterable_label_count,\n",
    "  CAST(content_creation_date AS TIMESTAMP) AS content_creation_ts\n",
    "FROM 'content/metadata.parquet';\n",
    "\n",
    "CREATE OR REPLACE VIEW price_reviews AS SELECT \n",
    "  content_id_hashed,\n",
    "  CAST(update_date AS TIMESTAMP) AS update_ts,\n",
    "  original_price,\n",
    "  selling_price,\n",
    "  discounted_price,\n",
    "  content_review_count,\n",
    "  content_review_wth_media_count,\n",
    "  content_rate_count,\n",
    "  content_rate_avg\n",
    "FROM 'content/price_rate_review_data.parquet';\n",
    "\n",
    "CREATE OR REPLACE VIEW content_sitewide AS SELECT \n",
    "  content_id_hashed,\n",
    "  CAST(date AS DATE) AS d,\n",
    "  total_click,\n",
    "  total_cart,\n",
    "  total_fav,\n",
    "  total_order\n",
    "FROM 'content/sitewide_log.parquet';\n",
    "\n",
    "CREATE OR REPLACE VIEW content_search AS SELECT \n",
    "  content_id_hashed,\n",
    "  CAST(date AS DATE) AS d,\n",
    "  total_search_impression,\n",
    "  total_search_click\n",
    "FROM 'content/search_log.parquet';\n",
    "\n",
    "CREATE OR REPLACE VIEW user_meta AS SELECT \n",
    "  user_id_hashed,\n",
    "  user_gender,\n",
    "  user_birth_year,\n",
    "  user_tenure_in_days\n",
    "FROM 'user/metadata.parquet';\n",
    "\n",
    "CREATE OR REPLACE VIEW user_sitewide AS SELECT \n",
    "  user_id_hashed,\n",
    "  CAST(ts_hour AS TIMESTAMP) AS ts,\n",
    "  total_click,\n",
    "  total_cart,\n",
    "  total_fav,\n",
    "  total_order\n",
    "FROM 'user/sitewide_log.parquet';\n",
    "\n",
    "CREATE OR REPLACE VIEW term_search AS SELECT \n",
    "  CAST(ts_hour AS TIMESTAMP) AS ts,\n",
    "  search_term_normalized,\n",
    "  total_search_impression,\n",
    "  total_search_click\n",
    "FROM 'term/search_log.parquet';\n",
    "\"\"\")\n",
    "\n",
    "###############################################################################\n",
    "# 2) Büyük tablolardan kalıcı özet (aggregate) tablolar\n",
    "###############################################################################\n",
    "print(\"[duckdb] Özet tablolar oluşturuluyor...\")\n",
    "\n",
    "# Ürün bazlı günlük özetler (genel ve son 30 gün)\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE TABLE agg_content_all AS\n",
    "SELECT\n",
    "  content_id_hashed,\n",
    "  AVG(total_click)  AS c_click_mean,\n",
    "  AVG(total_order)  AS c_order_mean,\n",
    "  SUM(total_order)  AS c_order_sum,\n",
    "  AVG(total_fav)    AS c_fav_mean,\n",
    "  AVG(total_cart)   AS c_cart_mean\n",
    "FROM content_sitewide\n",
    "GROUP BY 1;\n",
    "\"\"\")\n",
    "\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE TABLE agg_content_recent AS\n",
    "WITH mx AS (\n",
    "  SELECT content_id_hashed, MAX(d) AS max_d FROM content_sitewide GROUP BY 1\n",
    "),\n",
    "win AS (\n",
    "  SELECT s.* FROM content_sitewide s JOIN mx USING(content_id_hashed)\n",
    "  WHERE s.d >= max_d - INTERVAL 30 DAY\n",
    ")\n",
    "SELECT\n",
    "  content_id_hashed,\n",
    "  AVG(total_click) AS c_r30_click_mean,\n",
    "  AVG(total_order) AS c_r30_order_mean,\n",
    "  SUM(total_order) AS c_r30_order_sum\n",
    "FROM win\n",
    "GROUP BY 1;\n",
    "\"\"\")\n",
    "\n",
    "# Ürün bazlı arama CTR'ları\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE TABLE agg_content_search AS\n",
    "SELECT\n",
    "  content_id_hashed,\n",
    "  SUM(total_search_impression) AS c_imp_sum,\n",
    "  SUM(total_search_click)     AS c_clk_sum,\n",
    "  CASE WHEN SUM(total_search_impression) > 0\n",
    "       THEN SUM(total_search_click) / SUM(total_search_impression)\n",
    "       ELSE NULL END AS c_ctr\n",
    "FROM content_search\n",
    "GROUP BY 1;\n",
    "\"\"\")\n",
    "\n",
    "# Fiyat/puan (en güncel kayıt)\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE TABLE latest_price AS\n",
    "SELECT * FROM (\n",
    "  SELECT *, ROW_NUMBER() OVER (PARTITION BY content_id_hashed ORDER BY update_ts DESC) AS rn\n",
    "  FROM price_reviews\n",
    ") WHERE rn=1;\n",
    "\"\"\")\n",
    "\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE TABLE price_features AS\n",
    "SELECT\n",
    "  content_id_hashed,\n",
    "  original_price,\n",
    "  selling_price,\n",
    "  discounted_price,\n",
    "  content_rate_avg,\n",
    "  content_rate_count,\n",
    "  content_review_count,\n",
    "  content_review_wth_media_count,\n",
    "  CASE WHEN original_price IS NOT NULL AND original_price > 0\n",
    "       THEN (original_price - COALESCE(discounted_price, selling_price)) / original_price\n",
    "       ELSE NULL END AS discount_pct\n",
    "FROM latest_price;\n",
    "\"\"\")\n",
    "\n",
    "# Kullanıcı bazlı genel oranlar\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE TABLE agg_user AS\n",
    "SELECT\n",
    "  user_id_hashed,\n",
    "  AVG(total_click)  AS u_click_mean,\n",
    "  AVG(total_cart)   AS u_cart_mean,\n",
    "  AVG(total_fav)    AS u_fav_mean,\n",
    "  AVG(total_order)  AS u_order_mean\n",
    "FROM user_sitewide\n",
    "GROUP BY 1;\n",
    "\"\"\")\n",
    "\n",
    "# Arama terimi CTR\n",
    "con.execute(\"\"\"\n",
    "CREATE OR REPLACE TABLE agg_term AS\n",
    "SELECT\n",
    "  search_term_normalized,\n",
    "  SUM(total_search_impression) AS t_imp_sum,\n",
    "  SUM(total_search_click)     AS t_clk_sum,\n",
    "  CASE WHEN SUM(total_search_impression) > 0\n",
    "       THEN SUM(total_search_click) / SUM(total_search_impression)\n",
    "       ELSE NULL END AS t_ctr\n",
    "FROM term_search\n",
    "GROUP BY 1;\n",
    "\"\"\")\n",
    "\n",
    "###############################################################################\n",
    "# 3) Eğitim tablosu (feature join) – yalnız gerekli kolonlar\n",
    "###############################################################################\n",
    "print(\"[duckdb] Eğitim tablosu hazırlanıyor...\")\n",
    "train_df = con.execute(\"\"\"\n",
    "SELECT \n",
    "  t.session_id,\n",
    "  CAST(t.ts_hour AS TIMESTAMP) AS ts_hour,\n",
    "  t.search_term_normalized,\n",
    "  t.user_id_hashed,\n",
    "  t.content_id_hashed,\n",
    "  t.clicked,\n",
    "  t.ordered,\n",
    "  -- ürün özetleri\n",
    "  a.c_click_mean, a.c_order_mean, a.c_order_sum, a.c_fav_mean, a.c_cart_mean,\n",
    "  r.c_r30_click_mean, r.c_r30_order_mean, r.c_r30_order_sum,\n",
    "  s.c_imp_sum, s.c_clk_sum, s.c_ctr,\n",
    "  -- fiyat/puan\n",
    "  p.original_price, p.selling_price, p.discounted_price, p.discount_pct,\n",
    "  p.content_rate_avg, p.content_rate_count, p.content_review_count, p.content_review_wth_media_count,\n",
    "  -- kullanıcı özetleri\n",
    "  u.u_click_mean, u.u_cart_mean, u.u_fav_mean, u.u_order_mean,\n",
    "  -- terim özetleri\n",
    "  tm.t_imp_sum, tm.t_clk_sum, tm.t_ctr,\n",
    "  -- meta\n",
    "  m.attribute_type_count, m.total_attribute_option_count, m.merchant_count, m.filterable_label_count,\n",
    "  m.content_creation_ts,\n",
    "  -- türev: içerik yaş\n",
    "  DATE_DIFF('day', m.content_creation_ts, CAST(t.ts_hour AS TIMESTAMP)) AS days_since_creation\n",
    "FROM train_sessions t\n",
    "LEFT JOIN agg_content_all a     USING(content_id_hashed)\n",
    "LEFT JOIN agg_content_recent r  USING(content_id_hashed)\n",
    "LEFT JOIN agg_content_search s  USING(content_id_hashed)\n",
    "LEFT JOIN price_features p      USING(content_id_hashed)\n",
    "LEFT JOIN agg_user u            USING(user_id_hashed)\n",
    "LEFT JOIN agg_term tm           USING(search_term_normalized)\n",
    "LEFT JOIN content_meta m        USING(content_id_hashed)\n",
    "\"\"\").df()\n",
    "\n",
    "memory_info(train_df, \"train_df (joined)\")\n",
    "\n",
    "# Basit zamansal kolonlar\n",
    "train_df = add_time_parts(train_df, \"ts_hour\")\n",
    "\n",
    "# Nümerik tipleri hafifletme\n",
    "for c in train_df.select_dtypes(include=[\"float64\"]).columns:\n",
    "    train_df[c] = train_df[c].astype(\"float32\")\n",
    "# Güvenli integer downcast: NA varsa pandas'ın nullable Int32'sine çevir\n",
    "for c in train_df.select_dtypes(include=[\"int64\",\"Int64\"]).columns:\n",
    "    if c not in [\"clicked\", \"ordered\"]:\n",
    "        if train_df[c].isna().any():\n",
    "            train_df[c] = train_df[c].astype(\"Int32\")  # NA destekli\n",
    "        else:\n",
    "            train_df[c] = train_df[c].astype(\"int32\")\n",
    "\n",
    "memory_info(train_df, \"train_df (typed)\")\n",
    "\n",
    "###############################################################################\n",
    "# 4) Kategorik kodlama\n",
    "###############################################################################\n",
    "cat_cols = [\"search_term_normalized\", \"user_id_hashed\", \"content_id_hashed\"]\n",
    "train_df, encoders = label_encode_train_and_map(train_df, cat_cols)\n",
    "\n",
    "# Özellik listesi\n",
    "drop_cols = [\"session_id\", \"ts_hour\", \"clicked\", \"ordered\", \"content_creation_ts\"]\n",
    "features = [c for c in train_df.columns if c not in drop_cols]\n",
    "# Datetime kolonlarını modelden çıkar (LightGBM doğrudan desteklemez)\n",
    "from pandas.api.types import is_datetime64_any_dtype\n",
    "_dt_cols = [c for c in features if is_datetime64_any_dtype(train_df[c])]\n",
    "if _dt_cols:\n",
    "    print(\"[feat] dropping datetime cols:\", _dt_cols)\n",
    "    features = [c for c in features if c not in _dt_cols]\n",
    "print(f\"[feat] {len(features)} feature kullanılacak\")\n",
    "\n",
    "###############################################################################\n",
    "# 5) LightGBM – iki model (clicked & ordered)\n",
    "###############################################################################\n",
    "params = dict(\n",
    "    objective=\"binary\",\n",
    "    metric=\"auc\",\n",
    "    learning_rate=0.05,\n",
    "    num_leaves=96,\n",
    "    min_data_in_leaf=50,\n",
    "    feature_fraction=0.85,\n",
    "    bagging_fraction=0.85,\n",
    "    bagging_freq=1,\n",
    "    max_bin=255,\n",
    "    verbosity=-1,\n",
    "    seed=RANDOM_STATE,\n",
    ")\n",
    "\n",
    "# Oturum bazlı CV önerilir (aynı oturum train/valid karışmasın)\n",
    "cv = GroupKFold(n_splits=5)\n",
    "\n",
    "# LightGBM ile tip uyuşmazlıklarını önlemek için float32'e çevir\n",
    "X = train_df[features].astype(\"float32\")\n",
    "y_click = train_df[\"clicked\"].astype(int)\n",
    "y_order = train_df[\"ordered\"].astype(int)\n",
    "\n",
    "groups = train_df[\"session_id\"].values  # oturum bazlı grup\n",
    "\n",
    "\n",
    "def fit_lgb_cv(X, y, groups, label):\n",
    "    oof = np.zeros(len(X), dtype=float)\n",
    "    models = []\n",
    "    for fold, (tr, va) in enumerate(cv.split(X, y, groups)):\n",
    "        X_tr, y_tr = X.iloc[tr], y.iloc[tr]\n",
    "        X_va, y_va = X.iloc[va], y.iloc[va]\n",
    "        l_tr = lgb.Dataset(X_tr, label=y_tr, free_raw_data=False)\n",
    "        l_va = lgb.Dataset(X_va, label=y_va, free_raw_data=False)\n",
    "        print(f\"[lgb] {label} fold {fold}\")\n",
    "        model = lgb.train(\n",
    "            params,\n",
    "            l_tr,\n",
    "            valid_sets=[l_tr, l_va],\n",
    "            valid_names=[\"train\", \"valid\"],\n",
    "            num_boost_round=4000,\n",
    "            callbacks=[\n",
    "                lgb.early_stopping(stopping_rounds=150),\n",
    "                lgb.log_evaluation(period=200),\n",
    "            ],\n",
    "        )\n",
    "        models.append(model)\n",
    "        oof[va] = model.predict(X_va, num_iteration=model.best_iteration)\n",
    "    return models, oof\n",
    "\n",
    "click_models, oof_click = fit_lgb_cv(X, y_click, groups, label=\"clicked\")\n",
    "order_models, oof_order = fit_lgb_cv(X, y_order, groups, label=\"ordered\")\n",
    "\n",
    "# Basit OOF kombinasyonu (hackathon ağırlığına paralel)\n",
    "oof_final = 0.7 * oof_order + 0.3 * oof_click\n",
    "print(\"[info] OOF özet:\")\n",
    "print(pd.Series(oof_final).describe())\n",
    "\n",
    "# Önemli feature’lar (ilk 30)\n",
    "try:\n",
    "    importances = np.mean([m.feature_importance(importance_type='gain') for m in click_models + order_models], axis=0)\n",
    "    fi = pd.DataFrame({\"feature\": features, \"importance\": importances}).sort_values(\"importance\", ascending=False)\n",
    "    fi.head(30).to_csv(\"feature_importance_top30.csv\", index=False)\n",
    "    print(\"[info] feature_importance_top30.csv kaydedildi.\")\n",
    "except Exception as e:\n",
    "    print(\"[warn] Feature importance çıkarılamadı:\", e)\n",
    "\n",
    "###############################################################################\n",
    "# 6) Test feature’ları – batch içe al, encode et, tahmin et, sıralayıp yaz\n",
    "###############################################################################\n",
    "print(\"[duckdb] Test veri akışı başlıyor…\")\n",
    "\n",
    "# Test view hazır (yukarıda). Aynı join modeli ile test setini part part çekelim.\n",
    "\n",
    "def fetch_test_batch(offset: int, limit: int = 2_000_000):\n",
    "    q = f\"\"\"\n",
    "    SELECT \n",
    "      t.session_id,\n",
    "      CAST(t.ts_hour AS TIMESTAMP) AS ts_hour,\n",
    "      t.search_term_normalized,\n",
    "      t.user_id_hashed,\n",
    "      t.content_id_hashed,\n",
    "      a.c_click_mean, a.c_order_mean, a.c_order_sum, a.c_fav_mean, a.c_cart_mean,\n",
    "      r.c_r30_click_mean, r.c_r30_order_mean, r.c_r30_order_sum,\n",
    "      s.c_imp_sum, s.c_clk_sum, s.c_ctr,\n",
    "      p.original_price, p.selling_price, p.discounted_price, p.discount_pct,\n",
    "      p.content_rate_avg, p.content_rate_count, p.content_review_count, p.content_review_wth_media_count,\n",
    "      u.u_click_mean, u.u_cart_mean, u.u_fav_mean, u.u_order_mean,\n",
    "      tm.t_imp_sum, tm.t_clk_sum, tm.t_ctr,\n",
    "      m.attribute_type_count, m.total_attribute_option_count, m.merchant_count, m.filterable_label_count,\n",
    "      m.content_creation_ts,\n",
    "      DATE_DIFF('day', m.content_creation_ts, CAST(t.ts_hour AS TIMESTAMP)) AS days_since_creation\n",
    "    FROM test_sessions t\n",
    "    LEFT JOIN agg_content_all a     USING(content_id_hashed)\n",
    "    LEFT JOIN agg_content_recent r  USING(content_id_hashed)\n",
    "    LEFT JOIN agg_content_search s  USING(content_id_hashed)\n",
    "    LEFT JOIN price_features p      USING(content_id_hashed)\n",
    "    LEFT JOIN agg_user u            USING(user_id_hashed)\n",
    "    LEFT JOIN agg_term tm           USING(search_term_normalized)\n",
    "    LEFT JOIN content_meta m        USING(content_id_hashed)\n",
    "    ORDER BY t.session_id, t.content_id_hashed\n",
    "    LIMIT {limit} OFFSET {offset}\n",
    "    \"\"\"\n",
    "    df = con.execute(q).df()\n",
    "    return df\n",
    "\n",
    "\n",
    "def encode_and_timeparts(df: pd.DataFrame):\n",
    "    \"\"\"Feature type normalization for test batches.\n",
    "    - Adds time parts\n",
    "    - Safe integer downcast with NA-friendly Int32\n",
    "    - Preserves raw content_id for submission\n",
    "    - Label-encodes using fitted encoders\n",
    "    - Returns cleaned DataFrame\n",
    "    \"\"\"\n",
    "    df = add_time_parts(df, \"ts_hour\")\n",
    "\n",
    "    # Preserve raw content_id for submission before any encoding\n",
    "    if \"content_id_hashed\" in df.columns and \"content_id_raw\" not in df.columns:\n",
    "        df[\"content_id_raw\"] = df[\"content_id_hashed\"].astype(str)\n",
    "\n",
    "    # Downcast floats\n",
    "    for c in df.select_dtypes(include=[\"float64\"]).columns:\n",
    "        df[c] = df[c].astype(\"float32\")\n",
    "\n",
    "    # Safe integer downcast (keep NA as Int32)\n",
    "    for c in df.select_dtypes(include=[\"int64\",\"Int64\"]).columns:\n",
    "        if c not in [\"clicked\", \"ordered\"]:\n",
    "            if df[c].isna().any():\n",
    "                df[c] = df[c].astype(\"Int32\")\n",
    "            else:\n",
    "                df[c] = df[c].astype(\"int32\")\n",
    "\n",
    "    # Apply label encoders (extend with unknowns)\n",
    "    df = label_encode_apply(df, encoders)\n",
    "\n",
    "    return df\n",
    "\n",
    "\n",
    "def predict_batch(df: pd.DataFrame):\n",
    "    \"\"\"Predict scores for a test batch.\n",
    "    Ensures no datetime/object columns slip in and types are numeric float32.\n",
    "    \"\"\"\n",
    "    # Build candidate feature set and drop pure ID / timestamp columns\n",
    "    cols = [c for c in df.columns if c not in [\"session_id\", \"ts_hour\", \"content_creation_ts\", \"content_id_raw\"]]\n",
    "    Xb = df[cols].copy()\n",
    "\n",
    "    # Drop any datetime columns\n",
    "    from pandas.api.types import is_datetime64_any_dtype\n",
    "    dt_cols = [c for c in Xb.columns if is_datetime64_any_dtype(Xb[c])]\n",
    "    if dt_cols:\n",
    "        Xb = Xb.drop(columns=dt_cols)\n",
    "\n",
    "    # Keep only numeric columns (avoid stray objects)\n",
    "    num_cols = Xb.select_dtypes(include=[np.number]).columns.tolist()\n",
    "    if len(num_cols) != Xb.shape[1]:\n",
    "        Xb = Xb[num_cols]\n",
    "\n",
    "    # Ensure numeric type for LightGBM\n",
    "    Xb = Xb.astype(\"float32\", copy=False)\n",
    "\n",
    "    # Predict clicked\n",
    "    p_click = np.zeros(Xb.shape[0], dtype=np.float32)\n",
    "    for m in click_models:\n",
    "        p_click += m.predict(Xb, num_iteration=m.best_iteration)\n",
    "    if len(click_models) > 0:\n",
    "        p_click /= len(click_models)\n",
    "\n",
    "    # Predict ordered\n",
    "    p_order = np.zeros(Xb.shape[0], dtype=np.float32)\n",
    "    for m in order_models:\n",
    "        p_order += m.predict(Xb, num_iteration=m.best_iteration)\n",
    "    if len(order_models) > 0:\n",
    "        p_order /= len(order_models)\n",
    "\n",
    "    final = 0.7 * p_order + 0.3 * p_click\n",
    "\n",
    "    # Choose raw content id if present for submission\n",
    "    id_col = \"content_id_raw\" if \"content_id_raw\" in df.columns else \"content_id_hashed\"\n",
    "    out = pd.DataFrame({\n",
    "        \"session_id\": df[\"session_id\"].astype(str).values,\n",
    "        \"content_id\": df[id_col].astype(str).values,\n",
    "        \"final_score\": final,\n",
    "    })\n",
    "    return out\n",
    "\n",
    "\n",
    "print(\"[sanity] helpers defined:\", 'fetch_test_batch' in globals(), 'encode_and_timeparts' in globals(), 'predict_batch' in globals())\n",
    "\n",
    "parts = []\n",
    "offset = 0\n",
    "limit = 2_000_000\n",
    "leftover = pd.DataFrame()\n",
    "\n",
    "while True:\n",
    "    t0 = time.time()\n",
    "    tb = fetch_test_batch(offset, limit)\n",
    "    if len(tb) == 0:\n",
    "        break\n",
    "\n",
    "    # Carry-over: batch sınırında bölünen son session'ı sonraki batch'e taşı\n",
    "    if not leftover.empty:\n",
    "        tb = pd.concat([leftover, tb], ignore_index=True)\n",
    "        leftover = pd.DataFrame()\n",
    "\n",
    "    tb = tb.sort_values([\"session_id\"], kind=\"mergesort\").reset_index(drop=True)\n",
    "    last_sid = tb[\"session_id\"].iloc[-1]\n",
    "    mask_last = tb[\"session_id\"] == last_sid\n",
    "\n",
    "    current = tb.loc[~mask_last].copy()\n",
    "    leftover = tb.loc[mask_last].copy()\n",
    "\n",
    "    if not current.empty:\n",
    "        current = encode_and_timeparts(current)\n",
    "        pb = predict_batch(current)\n",
    "        # sıralı prediction string (ham content_id ile)\n",
    "        pb = (\n",
    "            pb.sort_values([\"session_id\", \"final_score\"], ascending=[True, False])\n",
    "              .groupby(\"session_id\")[\"content_id\"]\n",
    "              .apply(lambda s: \" \".join(s.astype(str)))\n",
    "              .reset_index(name=\"prediction\")\n",
    "        )\n",
    "        part_path = f\"submission_part_{offset}.csv\"\n",
    "        pb.to_csv(part_path, index=False)\n",
    "        parts.append(part_path)\n",
    "        dt = time.time() - t0\n",
    "        print(f\"[batch] written {part_path} in {dt:.1f}s rows={len(current)}\")\n",
    "        del current, pb\n",
    "        gc.collect()\n",
    "\n",
    "    offset += limit\n",
    "    del tb\n",
    "    gc.collect()\n",
    "\n",
    "# Son kalan session (tail) varsa işle\n",
    "if not leftover.empty:\n",
    "    print(f\"[batch] processing leftover rows={len(leftover)}\")\n",
    "    current = encode_and_timeparts(leftover)\n",
    "    pb = predict_batch(current)\n",
    "    pb = (\n",
    "        pb.sort_values([\"session_id\", \"final_score\"], ascending=[True, False])\n",
    "          .groupby(\"session_id\")[\"content_id\"]\n",
    "          .apply(lambda s: \" \".join(s.astype(str)))\n",
    "          .reset_index(name=\"prediction\")\n",
    "    )\n",
    "    part_path = \"submission_part_tail.csv\"\n",
    "    pb.to_csv(part_path, index=False)\n",
    "    parts.append(part_path)\n",
    "    del leftover, current, pb\n",
    "    gc.collect()\n",
    "\n",
    "# Parçaları birleştir\n",
    "if not parts:\n",
    "    raise RuntimeError(\"Test partları oluşmadı. Test dosyası boş olabilir.\")\n",
    "\n",
    "print(\"[merge] Parçalar birleştiriliyor…\")\n",
    "con.execute(\"CREATE OR REPLACE TABLE subs(partition INT, session_id VARCHAR, prediction VARCHAR);\")\n",
    "for i, p in enumerate(parts):\n",
    "    con.execute(\"INSERT INTO subs SELECT ?, * FROM read_csv_auto(?, HEADER=TRUE)\", [i, p])\n",
    "\n",
    "# Bazı yarışmalarda test birden çok parçaya bölünmüş olabilir; yine de session_id unique kalmalı\n",
    "submission = con.execute(\n",
    "    \"\"\"\n",
    "    WITH ranked AS (\n",
    "      SELECT partition, session_id, prediction,\n",
    "             ROW_NUMBER() OVER (PARTITION BY session_id ORDER BY partition DESC) AS rn\n",
    "      FROM subs\n",
    "    )\n",
    "    SELECT session_id, prediction\n",
    "    FROM ranked\n",
    "    WHERE rn = 1\n",
    "    \"\"\"\n",
    ").df()\n",
    "submission = submission.sort_values(\"session_id\").reset_index(drop=True)\n",
    "\n",
    "submission_path = \"submission.csv\"\n",
    "submission.to_csv(submission_path, index=False)\n",
    "# Sanity: benzersiz session sayısı kontrolü\n",
    "n_expected = con.execute(\"SELECT COUNT(DISTINCT session_id) FROM test_sessions\").fetchone()[0]\n",
    "print(f\"[sanity] uniq_session_in_submission={submission['session_id'].nunique()} expected={n_expected}\")\n",
    "print(f\"[sanity] uniq_session_in_submission={submission['session_id'].nunique()} expected={n_expected}\")\n",
    "print(f\"[done] submission yazıldı: {submission_path}, satır sayısı = {len(submission)} + başlık\")\n",
    "\n",
    "# Hızlı kontroller\n",
    "print(\"[check] İlk 3 satır:\")\n",
    "print(submission.head(3))\n",
    "\n",
    "# Kaggle CLI için örnek komut\n",
    "print(\"\\nKaggle'a gönderim için:\")\n",
    "print(\"kaggle competitions submit -c trendyol-e-ticaret-hackathonu-2025-kaggle -f submission.csv -m \\\"LGBM + geniş özellik seti\\\"\")\n"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "datasetId": 8073218,
     "sourceId": 12770585,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 31089,
   "isGpuEnabled": false,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.13"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 1521.846326,
   "end_time": "2025-08-18T07:42:00.498705",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-08-18T07:16:38.652379",
   "version": "2.6.0"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {
     "0af98cb81ec649d39a76900b8de147e0": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": "black",
       "description_width": ""
      }
     },
     "1b5a12e478354899b62c286efaa4b3d8": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": "black",
       "description_width": ""
      }
     },
     "1e77e757934b4f9ab5008cb6b9441b2a": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": "black",
       "description_width": ""
      }
     },
     "2113ab2cfdae406394c293d218afc2b8": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "auto"
      }
     },
     "260930d1453d4dc48516bba0188e20ee": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_6475788a63c949c3b1d89ede5446ea99",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_d7146e9126264edb8d4ca8f2ac5eaa67",
       "tabbable": null,
       "tooltip": null,
       "value": 100.0
      }
     },
     "31c37900087a48f1b4f35c8b443c8690": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_da07473ad84c4b629786323502d0f88b",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_1b5a12e478354899b62c286efaa4b3d8",
       "tabbable": null,
       "tooltip": null,
       "value": 100.0
      }
     },
     "3a7d492ee4c74ec5af072c5ff5ca2925": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "auto"
      }
     },
     "5474438d24754842917f82515657d63e": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_ce8de1a2a68f47fab6a933d93b3d1e2b",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_0af98cb81ec649d39a76900b8de147e0",
       "tabbable": null,
       "tooltip": null,
       "value": 100.0
      }
     },
     "6475788a63c949c3b1d89ede5446ea99": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "auto"
      }
     },
     "98078899925743b78400971e1fc704a7": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": "black",
       "description_width": ""
      }
     },
     "9f3aa9e0938b446d869d3b36d00c5842": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_3a7d492ee4c74ec5af072c5ff5ca2925",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_ce9c00c962e24c83a3dd594de403e4fb",
       "tabbable": null,
       "tooltip": null,
       "value": 100.0
      }
     },
     "a485eeb1932941bbb5df644b6802f32a": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "auto"
      }
     },
     "a6d233a62a3b44b486805c8f50f71450": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": "black",
       "description_width": ""
      }
     },
     "c1819e08ba3445579e8bdd1506ba24bc": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "auto"
      }
     },
     "cd8a722c47594b898875854aba237cdb": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_a485eeb1932941bbb5df644b6802f32a",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_a6d233a62a3b44b486805c8f50f71450",
       "tabbable": null,
       "tooltip": null,
       "value": 100.0
      }
     },
     "ce8de1a2a68f47fab6a933d93b3d1e2b": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "auto"
      }
     },
     "ce9c00c962e24c83a3dd594de403e4fb": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": "black",
       "description_width": ""
      }
     },
     "d5cb49fd4b9b4358be1c28ae1faea8ad": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_c1819e08ba3445579e8bdd1506ba24bc",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_1e77e757934b4f9ab5008cb6b9441b2a",
       "tabbable": null,
       "tooltip": null,
       "value": 100.0
      }
     },
     "d7146e9126264edb8d4ca8f2ac5eaa67": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": "black",
       "description_width": ""
      }
     },
     "da07473ad84c4b629786323502d0f88b": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": "auto"
      }
     },
     "f591e06733674fa9869f895785224e0f": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_2113ab2cfdae406394c293d218afc2b8",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_98078899925743b78400971e1fc704a7",
       "tabbable": null,
       "tooltip": null,
       "value": 100.0
      }
     }
    },
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
